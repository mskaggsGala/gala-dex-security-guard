const axios = require('axios');
const fs = require('fs');
const path = require('path');
const config = require('./config');

/**
 * Phase 9: Business Logic Exploits
 * Testing Token Economics, Governance, and Protocol-Specific Vulnerabilities
 */
class BusinessLogicExploitsTester {
    constructor() {
        this.apiUrl = config.apiUrl;
        this.results = [];
        this.criticalFindings = [];
        this.testCount = 0;
        this.passedCount = 0;
    }

    // Helper to log results
    logResult(category, test, passed, severity, details, recommendation) {
        const result = {
            category,
            test,
            passed,
            severity: passed ? 'PASS' : severity,
            details,
            recommendation,
            timestamp: new Date().toISOString()
        };
        
        this.results.push(result);
        this.testCount++;
        
        if (passed) {
            this.passedCount++;
        } else if (severity === 'CRITICAL' || severity === 'HIGH') {
            this.criticalFindings.push(result);
        }
        
        const status = passed ? '✅' : '❌';
        console.log(`${status} ${test}: ${passed ? 'PASSED' : severity}`);
        if (!passed && details) {
            console.log(`   Details: ${typeof details === 'object' ? JSON.stringify(details) : details}`);
        }
    }

    // Test 1: Token Economics Manipulation
    async testTokenEconomicsManipulation() {
        console.log('\n💰 Testing Token Economics Manipulation...');
        
        const tests = [
            {
                name: 'Infinite Token Minting',
                test: async () => {
                    try {
                        const response = await axios.post(`${this.apiUrl}/v1/tokens/mint`, {
                            tokenClass: 'GALA$Unit$none$none',
                            amount: '999999999999999999999', // Extremely large amount
                            recipient: 'attacker_wallet',
                            overrideLimits: true
                        }, {
                            validateStatus: () => true
                        });
                        
                        return {
                            vulnerable: response.status === 200 && response.data?.minted,
                            status: response.status,
                            amountMinted: response.data?.amountMinted
                        };
                    } catch (error) {
                        return {
                            vulnerable: false,
                            status: error.response?.status || 'error'
                        };
                    }
                }
            },
            {
                name: 'Supply Cap Bypass',
                test: async () => {
                    try {
                        // Attempt to mint beyond maximum supply
                        const response = await axios.post(`${this.apiUrl}/v1/tokens/mint`, {
                            tokenClass: 'LIMITED_TOKEN',
                            amount: '1000000',
                            currentSupply: '999999000', // Close to max
                            maxSupply: '1000000000',    // Max cap
                            bypassSupplyCheck: true
                        }, {
                            validateStatus: () => true
                        });
                        
                        return {
                            vulnerable: response.status === 200 && response.data?.exceedsSupplyCap,
                            status: response.status
                        };
                    } catch (error) {
                        return {
                            vulnerable: false,
                            status: error.response?.status || 'error'
                        };
                    }
                }
            },
            {
                name: 'Token Burn Manipulation',
                test: async () => {
                    try {
                        const response = await axios.post(`${this.apiUrl}/v1/tokens/burn`, {
                            tokenClass: 'GALA$Unit$none$none',
                            amount: '100000',
                            fromAddress: 'other_user_wallet', // Burn someone else's tokens
                            authorization: 'FORGED'
                        }, {
                            validateStatus: () => true
                        });
                        
                        return {
                            vulnerable: response.status === 200 && response.data?.burned,
                            status: response.status
                        };
                    } catch (error) {
                        return {
                            vulnerable: false,
                            status: error.response?.status || 'error'
                        };
                    }
                }
            }
        ];

        let vulnerableCount = 0;
        const results = [];

        for (const test of tests) {
            try {
                const result = await test.test();
                results.push({
                    test: test.name,
                    ...result
                });
                if (result.vulnerable) vulnerableCount++;
            } catch (error) {
                results.push({
                    test: test.name,
                    error: error.message
                });
            }
        }

        const passed = vulnerableCount === 0;
        this.logResult(
            'Business Logic Exploits',
            'Token Economics Manipulation',
            passed,
            vulnerableCount > 0 ? 'CRITICAL' : 'PASS',
            results,
            passed ? 'Token economics properly secured' : 'Implement strict token supply controls and authorization checks'
        );
    }

    // Test 2: Governance Attack Vectors
    async testGovernanceAttackVectors() {
        console.log('\n🏛️ Testing Governance Attack Vectors...');
        
        const tests = [
            {
                name: 'Vote Buying/Manipulation',
                payload: {
                    proposal: 'MALICIOUS_PROPOSAL_001',
                    votes: [
                        { voter: 'bought_voter_1', power: 1000000, paid: true },
                        { voter: 'bought_voter_2', power: 2000000, paid: true },
                        { voter: 'bought_voter_3', power: 1500000, paid: true }
                    ],
                    totalBribery: '100000',
                    proposal_details: {
                        action: 'DRAIN_TREASURY',
                        beneficiary: 'attacker_wallet'
                    }
                }
            },
            {
                name: 'Flash Loan Governance Attack',
                payload: {
                    attack_sequence: [
                        {
                            step: 1,
                            action: 'FLASH_LOAN_GOVERNANCE_TOKENS',
                            amount: '10000000'
                        },
                        {
                            step: 2,
                            action: 'SUBMIT_MALICIOUS_PROPOSAL',
                            proposal: 'EMERGENCY_PARAMETER_CHANGE'
                        },
                        {
                            step: 3,
                            action: 'VOTE_WITH_BORROWED_TOKENS',
                            vote: 'YES'
                        },
                        {
                            step: 4,
                            action: 'EXECUTE_PROPOSAL_IMMEDIATELY',
                            bypass_timelock: true
                        }
                    ]
                }
            },
            {
                name: 'Timelock Bypass',
                payload: {
                    proposal: 'CRITICAL_SYSTEM_CHANGE',
                    timelock_period: '7_days',
                    bypass_methods: [
                        'EMERGENCY_OVERRIDE',
                        'ADMIN_PRIVILEGE_ESCALATION',
                        'MULTI_SIG_COMPROMISE'
                    ],
                    execute_immediately: true
                }
            },
            {
                name: 'Proposal Spam Attack',
                payload: {
                    spam_proposals: [
                        { id: 'spam_1', cost: '0.001' },
                        { id: 'spam_2', cost: '0.001' },
                        { id: 'spam_3', cost: '0.001' }
                        // ... repeat 1000 times
                    ],
                    block_legitimate_proposals: true,
                    ddos_governance: true
                }
            }
        ];

        const results = [];
        let vulnerableCount = 0;

        for (const test of tests) {
            try {
                const response = await axios.post(
                    `${this.apiUrl}/v1/governance/attack-test`,
                    test.payload,
                    { validateStatus: () => true }
                );
                
                const vulnerable = response.status === 200 && 
                                 (response.data?.proposalPassed === true ||
                                  response.data?.governanceCompromised === true ||
                                  response.data?.timelockBypassed === true);
                
                if (vulnerable) vulnerableCount++;
                
                results.push({
                    test: test.name,
                    vulnerable,
                    status: response.status,
                    governanceIntegrity: !vulnerable
                });
            } catch (error) {
                results.push({
                    test: test.name,
                    error: error.message
                });
            }
        }

        const passed = vulnerableCount === 0;
        this.logResult(
            'Business Logic Exploits',
            'Governance Attack Vectors',
            passed,
            vulnerableCount > 0 ? 'CRITICAL' : 'PASS',
            results,
            passed ? 'Governance mechanisms properly secured' : 'Implement robust governance protections including vote delegation limits and timelock enforcement'
        );
    }

    // Test 3: Economic Incentive Attacks
    async testEconomicIncentiveAttacks() {
        console.log('\n🎯 Testing Economic Incentive Attacks...');
        
        const tests = [
            {
                name: 'Liquidity Mining Exploit',
                test: async () => {
                    try {
                        // Attempt to game liquidity rewards
                        const response = await axios.post(`${this.apiUrl}/v1/liquidity/farm-exploit`, {
                            strategy: 'SANDWICH_FARMING',
                            steps: [
                                'ADD_LIQUIDITY_BEFORE_EPOCH',
                                'CLAIM_REWARDS',
                                'REMOVE_LIQUIDITY_AFTER_REWARD',
                                'REPEAT_CYCLE'
                            ],
                            target_reward: '1000000',
                            actual_liquidity_provided: '100'
                        }, {
                            validateStatus: () => true
                        });
                        
                        return {
                            vulnerable: response.status === 200 && response.data?.exploitSuccessful,
                            status: response.status,
                            rewardsExploited: response.data?.rewardsGained
                        };
                    } catch (error) {
                        return {
                            vulnerable: false,
                            status: error.response?.status || 'error'
                        };
                    }
                }
            },
            {
                name: 'Fee Structure Manipulation',
                test: async () => {
                    try {
                        const response = await axios.post(`${this.apiUrl}/v1/trading/fee-manipulation`, {
                            manipulation_type: 'FEE_TIER_GAMING',
                            fake_volume: '10000000',
                            actual_volume: '1000',
                            target_tier: 'VIP_ZERO_FEE',
                            exploit_referral_system: true
                        }, {
                            validateStatus: () => true
                        });
                        
                        return {
                            vulnerable: response.status === 200 && response.data?.feeReduction > 0,
                            status: response.status,
                            feeReduction: response.data?.feeReduction
                        };
                    } catch (error) {
                        return {
                            vulnerable: false,
                            status: error.response?.status || 'error'
                        };
                    }
                }
            },
            {
                name: 'Staking Reward Manipulation',
                test: async () => {
                    try {
                        const response = await axios.post(`${this.apiUrl}/v1/staking/reward-exploit`, {
                            exploit_type: 'COMPOUND_TIMING',
                            stake_amount: '100000',
                            unstake_immediately: true,
                            claim_before_unstake: true,
                            multiple_accounts: ['account_1', 'account_2', 'account_3'],
                            coordinate_timing: true
                        }, {
                            validateStatus: () => true
                        });
                        
                        return {
                            vulnerable: response.status === 200 && response.data?.extraRewards > 0,
                            status: response.status,
                            extraRewards: response.data?.extraRewards
                        };
                    } catch (error) {
                        return {
                            vulnerable: false,
                            status: error.response?.status || 'error'
                        };
                    }
                }
            }
        ];

        const results = [];
        let vulnerableCount = 0;

        for (const test of tests) {
            const result = await test.test();
            results.push({
                test: test.name,
                ...result
            });
            if (result.vulnerable) vulnerableCount++;
        }

        const passed = vulnerableCount === 0;
        this.logResult(
            'Business Logic Exploits',
            'Economic Incentive Attacks',
            passed,
            vulnerableCount > 0 ? 'HIGH' : 'PASS',
            results,
            passed ? 'Economic incentives properly aligned' : 'Review and strengthen economic incentive mechanisms to prevent gaming'
        );
    }

    // Test 4: Protocol Parameter Manipulation
    async testProtocolParameterManipulation() {
        console.log('\n⚙️ Testing Protocol Parameter Manipulation...');
        
        const tests = [
            {
                name: 'Critical Parameter Bypass',
                payload: {
                    parameter_changes: {
                        max_trade_size: 'UNLIMITED',
                        min_liquidity_requirement: '0',
                        fee_percentage: '-1', // Negative fee = protocol pays users
                        slippage_protection: 'DISABLED'
                    },
                    authorization: 'ADMIN_OVERRIDE',
                    bypass_governance: true
                }
            },
            {
                name: 'Oracle Price Manipulation',
                payload: {
                    manipulation_type: 'ORACLE_ATTACK',
                    target_price: '999999999',
                    actual_price: '100',
                    oracle_sources: [
                        { source: 'MANIPULATED_DEX', price: '999999999' },
                        { source: 'COMPROMISED_API', price: '999999998' },
                        { source: 'LEGITIMATE_SOURCE', price: '100' }
                    ],
                    median_override: true
                }
            },
            {
                name: 'Emergency Stop Abuse',
                payload: {
                    trigger_emergency_stop: true,
                    reason: 'FALSE_EMERGENCY',
                    prevent_withdrawals: true,
                    admin_privileges: ['DRAIN_DURING_PAUSE'],
                    restart_immediately: true
                }
            },
            {
                name: 'Upgrade Logic Bypass',
                payload: {
                    upgrade_type: 'MALICIOUS_CONTRACT',
                    new_contract_code: 'BACKDOORED_IMPLEMENTATION',
                    skip_upgrade_delay: true,
                    bypass_multi_sig: true,
                    preserve_admin_access: true
                }
            }
        ];

        const results = [];
        let vulnerableCount = 0;

        for (const test of tests) {
            try {
                const response = await axios.post(
                    `${this.apiUrl}/v1/protocol/parameter-test`,
                    test.payload,
                    { validateStatus: () => true }
                );
                
                const vulnerable = response.status === 200 && 
                                 (response.data?.parametersChanged === true ||
                                  response.data?.protocolCompromised === true ||
                                  response.data?.upgradeSuccessful === true);
                
                if (vulnerable) vulnerableCount++;
                
                results.push({
                    test: test.name,
                    vulnerable,
                    status: response.status,
                    protocolIntegrity: !vulnerable
                });
            } catch (error) {
                results.push({
                    test: test.name,
                    error: error.message
                });
            }
        }

        const passed = vulnerableCount === 0;
        this.logResult(
            'Business Logic Exploits',
            'Protocol Parameter Manipulation',
            passed,
            vulnerableCount > 0 ? 'CRITICAL' : 'PASS',
            results,
            passed ? 'Protocol parameters properly protected' : 'Implement strict parameter change controls and multi-signature requirements'
        );
    }

    // Test 5: Cross-Protocol Exploits
    async testCrossProtocolExploits() {
        console.log('\n🌉 Testing Cross-Protocol Exploits...');
        
        const tests = [
            {
                name: 'Bridge Exploit Chain',
                test: async () => {
                    try {
                        const response = await axios.post(`${this.apiUrl}/v1/bridge/exploit-chain`, {
                            exploit_sequence: [
                                {
                                    protocol: 'SOURCE_CHAIN',
                                    action: 'DEPOSIT_TOKENS',
                                    amount: '1000000'
                                },
                                {
                                    protocol: 'BRIDGE',
                                    action: 'DOUBLE_SPEND_ATTACK',
                                    exploit_finality: true
                                },
                                {
                                    protocol: 'TARGET_CHAIN',
                                    action: 'MINT_DUPLICATE_TOKENS',
                                    amount: '1000000'
                                },
                                {
                                    protocol: 'DEX',
                                    action: 'DUMP_DUPLICATE_TOKENS',
                                    crash_price: true
                                }
                            ]
                        }, {
                            validateStatus: () => true
                        });
                        
                        return {
                            vulnerable: response.status === 200 && response.data?.exploitSuccessful,
                            status: response.status,
                            tokensExploited: response.data?.tokensGained
                        };
                    } catch (error) {
                        return {
                            vulnerable: false,
                            status: error.response?.status || 'error'
                        };
                    }
                }
            },
            {
                name: 'Oracle Dependencies Exploit',
                test: async () => {
                    try {
                        const response = await axios.post(`${this.apiUrl}/v1/oracle/dependency-exploit`, {
                            target_protocols: ['DEX', 'LENDING', 'DERIVATIVES'],
                            oracle_manipulation: {
                                price_deviation: '1000%',
                                affected_pairs: ['GALA/USDC', 'GALA/ETH'],
                                cascade_effect: true
                            },
                            liquidation_cascade: true,
                            profit_extraction: '5000000'
                        }, {
                            validateStatus: () => true
                        });
                        
                        return {
                            vulnerable: response.status === 200 && response.data?.cascadeTriggered,
                            status: response.status,
                            protocolsAffected: response.data?.affectedProtocols?.length || 0
                        };
                    } catch (error) {
                        return {
                            vulnerable: false,
                            status: error.response?.status || 'error'
                        };
                    }
                }
            },
            {
                name: 'Composability Attack',
                test: async () => {
                    try {
                        const response = await axios.post(`${this.apiUrl}/v1/composability/exploit`, {
                            attack_vector: 'RECURSIVE_CALL_EXPLOIT',
                            target_protocols: [
                                'LENDING_PROTOCOL',
                                'DEX_PROTOCOL', 
                                'YIELD_FARMING_PROTOCOL'
                            ],
                            exploit_flow: [
                                'BORROW_FROM_LENDING',
                                'TRADE_ON_DEX',
                                'STAKE_IN_YIELD_FARM',
                                'CLAIM_REWARDS',
                                'RECURSIVE_CALL_BEFORE_STATE_UPDATE'
                            ]
                        }, {
                            validateStatus: () => true
                        });
                        
                        return {
                            vulnerable: response.status === 200 && response.data?.reentrancySuccessful,
                            status: response.status,
                            recursiveCallsExecuted: response.data?.recursiveCalls
                        };
                    } catch (error) {
                        return {
                            vulnerable: false,
                            status: error.response?.status || 'error'
                        };
                    }
                }
            }
        ];

        const results = [];
        let vulnerableCount = 0;

        for (const test of tests) {
            const result = await test.test();
            results.push({
                test: test.name,
                ...result
            });
            if (result.vulnerable) vulnerableCount++;
        }

        const passed = vulnerableCount === 0;
        this.logResult(
            'Business Logic Exploits',
            'Cross-Protocol Exploits',
            passed,
            vulnerableCount > 0 ? 'CRITICAL' : 'PASS',
            results,
            passed ? 'Cross-protocol interactions properly secured' : 'Implement circuit breakers and cross-protocol validation checks'
        );
    }

    // Test 6: State Transition Exploits
    async testStateTransitionExploits() {
        console.log('\n🔄 Testing State Transition Exploits...');
        
        const tests = [
            {
                name: 'Race Condition Exploit',
                test: async () => {
                    const promises = [];
                    
                    // Attempt simultaneous state transitions
                    for (let i = 0; i < 10; i++) {
                        promises.push(
                            axios.post(`${this.apiUrl}/v1/state/concurrent-update`, {
                                user: 'race_condition_user',
                                action: 'WITHDRAW',
                                amount: '10000',
                                balance_check: 'SKIP_DURING_RACE',
                                transaction_id: `race_${i}`
                            }, {
                                timeout: 1000,
                                validateStatus: () => true
                            }).catch(() => ({ status: 'timeout' }))
                        );
                    }
                    
                    const results = await Promise.allSettled(promises);
                    const successful = results.filter(r => 
                        r.status === 'fulfilled' && 
                        r.value.status === 200
                    ).length;
                    
                    return {
                        vulnerable: successful > 5, // If >5 concurrent operations succeeded
                        status: 'race_condition_test',
                        details: {
                            attemptedOperations: 10,
                            successfulOperations: successful,
                            raceConditionExploited: successful > 5
                        }
                    };
                }
            },
            {
                name: 'State Inconsistency Attack',
                test: async () => {
                    try {
                        const response = await axios.post(`${this.apiUrl}/v1/state/inconsistency-test`, {
                            operation_sequence: [
                                {
                                    action: 'START_TRANSACTION',
                                    state_snapshot: 'CAPTURE'
                                },
                                {
                                    action: 'MODIFY_EXTERNAL_STATE',
                                    target: 'ORACLE_PRICE'
                                },
                                {
                                    action: 'COMPLETE_TRANSACTION',
                                    use_stale_state: true
                                }
                            ]
                        }, {
                            validateStatus: () => true
                        });
                        
                        return {
                            vulnerable: response.status === 200 && response.data?.stateInconsistent,
                            status: response.status,
                            stateConsistent: !response.data?.stateInconsistent
                        };
                    } catch (error) {
                        return {
                            vulnerable: false,
                            status: error.response?.status || 'error'
                        };
                    }
                }
            }
        ];

        const results = [];
        let vulnerableCount = 0;

        for (const test of tests) {
            const result = await test.test();
            results.push({
                test: test.name,
                ...result
            });
            if (result.vulnerable) vulnerableCount++;
        }

        const passed = vulnerableCount === 0;
        this.logResult(
            'Business Logic Exploits',
            'State Transition Exploits',
            passed,
            vulnerableCount > 0 ? 'HIGH' : 'PASS',
            results,
            passed ? 'State transitions properly secured' : 'Implement atomic operations and state consistency checks'
        );
    }

    // Main test runner
    async runTests() {
        console.log('\n' + '='.repeat(70));
        console.log('PHASE 9: BUSINESS LOGIC EXPLOITS');
        console.log('Testing Token Economics, Governance, and Protocol Logic');
        console.log('='.repeat(70));

        const startTime = Date.now();

        try {
            await this.testTokenEconomicsManipulation();
            await this.testGovernanceAttackVectors();
            await this.testEconomicIncentiveAttacks();
            await this.testProtocolParameterManipulation();
            await this.testCrossProtocolExploits();
            await this.testStateTransitionExploits();
        } catch (error) {
            console.error('Error during business logic exploits testing:', error);
            this.logResult(
                'Business Logic Exploits',
                'Test Execution',
                false,
                'ERROR',
                { error: error.message },
                'Fix test execution errors'
            );
        }

        const duration = Date.now() - startTime;

        // Generate summary
        const summary = {
            phase: 'Phase 9 - Business Logic Exploits',
            timestamp: new Date().toISOString(),
            duration: `${duration}ms`,
            totalTests: this.testCount,
            passed: this.passedCount,
            failed: this.testCount - this.passedCount,
            passRate: `${Math.round((this.passedCount / this.testCount) * 100)}%`,
            criticalFindings: this.criticalFindings.length,
            tests: this.results
        };

        // Save results
        this.saveResults(summary);

        // Print summary
        this.printSummary(summary);

        return summary;
    }

    // Save results to file
    saveResults(summary) {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `security-Phase-9-BusinessLogic-${timestamp}.json`;
        const filepath = path.join(config.directories.results, filename);
        
        fs.writeFileSync(filepath, JSON.stringify(summary, null, 2));
        console.log(`\nResults saved to: ${filepath}`);
    }

    // Print test summary
    printSummary(summary) {
        console.log('\n' + '='.repeat(70));
        console.log('PHASE 9 SUMMARY');
        console.log('='.repeat(70));
        console.log(`Total Tests: ${summary.totalTests}`);
        console.log(`Passed: ${summary.passed}`);
        console.log(`Failed: ${summary.failed}`);
        console.log(`Pass Rate: ${summary.passRate}`);
        console.log(`Critical Findings: ${summary.criticalFindings}`);
        
        if (this.criticalFindings.length > 0) {
            console.log('\n⚠️  CRITICAL FINDINGS:');
            this.criticalFindings.forEach(finding => {
                console.log(`\n  ${finding.test} (${finding.severity})`);
                console.log(`  Details: ${JSON.stringify(finding.details)}`);
                console.log(`  Action: ${finding.recommendation}`);
            });
        }
    }
}

// Export for use in security monitor
module.exports = BusinessLogicExploitsTester;

// Run standalone if called directly
if (require.main === module) {
    const tester = new BusinessLogicExploitsTester();
    tester.runTests().then(() => {
        console.log('\nPhase 9 Business Logic Exploits Testing Complete!');
    }).catch(error => {
        console.error('Error:', error);
        process.exit(1);
    });
}